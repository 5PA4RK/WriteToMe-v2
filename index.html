<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>WriteToMe - Secure Chat</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
<script src="https://unpkg.com/@supabase/supabase-js"></script>
<style>
/* (Your CSS styles remain similar, with minor adjustments for new features) */
:root {
  --dark-bg: #2a2a2a;
  --darker-bg: #333;
  --card-bg: #3a3a3a;
  --border-color: #555;
  --text-primary: #f8f8f8;
  --text-secondary: #ddd;
  --accent-orange: #ff9800;
  --accent-orange-dark: #e68900;
  --success-green: #4caf50;
  --danger-red: #f44336;
  --warning-yellow: #ffc107;
}
/* ... Rest of your CSS ... (unchanged, plus some for active session highlight) ... */
.session-card-active {
  border: 2px solid #4caf50;
  background-color: #2f2f2f;
}
</style>
</head>
<body>

<!-- Connection Modal for host acceptance -->
<div id="connectionModal" class="connection-modal">
  <div class="modal-content">
    <div class="modal-header"><h2><i class="fas fa-user-shield"></i> Secure Connection</h2></div>
    <div class="modal-body">
      <div class="login-form">
        <div class="form-group">
          <label><i class="fas fa-user"></i> Role:</label>
          <select id="userSelect" class="form-input">
            <option value="guest">Guest</option>
            <option value="host">Host</option>
          </select>
        </div>
        <div class="form-group">
          <label><i class="fas fa-lock"></i> Password:</label>
          <input type="password" id="passwordInput" class="form-input" placeholder="Enter password"/>
          <div class="password-hint" id="passwordHint"></div>
        </div>
        <div id="passwordError" class="error-message" style="display:none;">Incorrect password</div>
        <button id="connectBtn" class="btn" style="width:100%; margin-top:20px;"><i class="fas fa-plug"></i> Connect</button>
      </div>
    </div>
  </div>
</div>

<header>
  <div class="container">
    <div class="header-content">
      <div class="logo"><i class="fas fa-comment-alt"></i><h1>WriteToMe</h1></div>
      <div class="header-controls">
        <div class="user-status" id="userStatus">
          <div id="statusIndicator" class="status-indicator offline"></div>
          <span id="userRoleDisplay">Disconnected</span>
        </div>
        <button id="logoutBtn" class="btn btn-secondary" style="display:none;"><i class="fas fa-sign-out-alt"></i> Logout</button>
      </div>
    </div>
  </div>
</header>

<div class="container">
<div class="main-app">
  <!-- Chat Section -->
  <section class="chat-section">
    <div class="section-header">
      <h2><i class="fas fa-comments"></i> Secure Chat</h2>
      <button id="clearChatBtn" class="btn btn-danger"><i class="fas fa-trash-alt"></i> Clear Chat</button>
      <button id="reviewHistoryBtn" class="btn btn-secondary" style="margin-left:10px;"><i class="fas fa-history"></i> Review History</button>
    </div>
    <div class="chat-messages" id="chatMessages">
      <!-- Messages will load here -->
    </div>
    <div id="typingIndicator" class="typing-indicator"><i class="fas fa-pencil-alt"></i> <span id="typingUser"></span> is typing...</div>
    <div class="chat-input-area">
      <input type="text" id="messageInput" class="chat-input" placeholder="Type message..." disabled />
      <button id="sendMessageBtn" class="btn"><i class="fas fa-paper-plane"></i> Send</button>
    </div>
  </section>
  <!-- Instead of separate image tray, user can send images URLs or upload in message -->
</div>
<!-- Admin Panel -->
<div class="admin-panel" id="adminPanel" style="display:none;">
  <div class="admin-header" id="adminToggle">
    <h3><i class="fas fa-user-secret"></i> Admin Panel - Sessions</h3>
    <i class="fas fa-chevron-down"></i>
  </div>
  <div class="admin-content" id="adminContent" style="display:none;">
    <div id="sessionsContainer"></div>
    <button id="refreshSessionsBtn" class="btn"><i class="fas fa-sync-alt"></i> Refresh Sessions</button>
  </div>
</div>
</div>

<footer>
  <div class="container">
    <p>WriteToMe &copy; 2023 - Secure Two-Person Communication Platform | End-to-End Encrypted</p>
  </div>
</footer>

<!-- Hidden file input for image upload -->
<input type="file" id="fileInput" accept="image/*" style="display:none;" />

<script>
/* --- Configuration --- */
const SUPABASE_URL = 'https://YOUR-SUPABASE-URL'; // <-- Replace
const SUPABASE_ANON_KEY = 'YOUR-ANON-KEY'; // <-- Replace
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/* --- App State --- */
const state = {
  isHost: false,
  userId: null,
  userName: 'Guest',
  sessionId: null,
  connected: false,
  messages: [],
  currentImage: null,
  typingTimeout: null,
  isTyping: false,
  isAdmin: false,
  realTimeSubs: [],
  activeSessionCardId: null
};

/* --- DOM Elements --- */
const modal = document.getElementById('connectionModal');
const connectBtn = document.getElementById('connectBtn');
const logoutBtn = document.getElementById('logoutBtn');
const userStatus = document.getElementById('userStatus');
const userRoleDisplay = document.getElementById('userRoleDisplay');
const statusIndicator = document.getElementById('statusIndicator');
const chatMessages = document.getElementById('chatMessages');
const messageInput = document.getElementById('messageInput');
const sendBtn = document.getElementById('sendMessageBtn');
const clearChatBtn = document.getElementById('clearChatBtn');
const reviewHistoryBtn = document.getElementById('reviewHistoryBtn');
const adminPanel = document.getElementById('adminPanel');
const adminToggle = document.getElementById('adminToggle');
const adminContent = document.getElementById('adminContent');
const sessionsContainer = document.getElementById('sessionsContainer');
const refreshSessionsBtn = document.getElementById('refreshSessionsBtn');
const typingIndicator = document.getElementById('typingIndicator');
const typingUserSpan = document.getElementById('typingUser');
const fileInput = document.getElementById('fileInput');

/* --- Initialization --- */
init();

async function init() {
  loadSessionFromStorage();
  setupEventListeners();
  if (!state.connected) showConnectionModal();
  else {
    await reconnect();
  }
}

// Load session info from localStorage
function loadSessionFromStorage() {
  const sessionStr = localStorage.getItem('writeToMe_session');
  if (sessionStr) {
    const data = JSON.parse(sessionStr);
    state.isHost = data.isHost;
    state.userId = data.userId;
    state.userName = data.userName;
    state.sessionId = data.sessionId;
    state.connected = true;
    updateUIConnected();
    loadChatHistory();
    loadCurrentImage();
    if (state.isHost) {
      showAdminPanel();
      refreshSessions();
    }
  }
}

function showConnectionModal() {
  modal.style.display = 'flex';
}
function hideConnectionModal() { modal.style.display='none'; }
function updateUIConnected() {
  statusIndicator.classList.remove('offline');
  userRoleDisplay.textContent = `${state.userName} (Connected)`;
  logoutBtn.style.display='inline-block';
  messageInput.disabled=false;
  sendBtn.disabled=false;
  // Show active session card
  highlightActiveSessionCard();
}
function updateUIDisconnected() {
  statusIndicator.classList.add('offline');
  userRoleDisplay.textContent = 'Disconnected';
  logoutBtn.style.display='none';
  messageInput.disabled=true;
  sendBtn.disabled=true;
  clearChat();
}

/* --- Event Listeners --- */
function setupEventListeners() {
  document.getElementById('userSelect').addEventListener('change', e => {
    // optional: show hints
  });
  document.getElementById('connectBtn').addEventListener('click', handleConnect);
  logoutBtn.addEventListener('click', handleLogout);
  sendBtn.addEventListener('click', sendMessage);
  messageInput.addEventListener('keypress', e => {
    if (e.key=='Enter') sendMessage();
    handleTypingStatus();
  });
  clearChatBtn.addEventListener('click', clearChat);
  reviewHistoryBtn.addEventListener('click', reviewHistory);
  document.getElementById('reviewHistoryBtn').addEventListener('click', reviewHistory);
  // Admin panel toggle
  adminToggle.addEventListener('click', toggleAdminPanel);
  refreshSessionsBtn.addEventListener('click', refreshSessions);
  // File upload
  document.getElementById('fileInput').addEventListener('change', handleFileUpload);
}

/* --- Connect & Authentication --- */
async function handleConnect() {
  const role = document.getElementById('userSelect').value;
  const password = document.getElementById('passwordInput').value;
  // Validate password
  if (role==='host') {
    if (password !== 'YourHostPassword') {
      showError('Incorrect host password');
      return;
    }
    state.isHost = true;
  } else {
    if (password !== 'YourGuestPassword') {
      showError('Incorrect guest password');
      return;
    }
    state.isHost = false;
  }
  // Create or join session
  await createOrJoinSession();
  hideConnectionModal();
  updateUIConnected();
  saveSessionToStorage();
  if (state.isHost) {
    showAdminPanel();
    refreshSessions();
  }
}

// Save session info to localStorage
function saveSessionToStorage() {
  localStorage.setItem('writeToMe_session', JSON.stringify({
    isHost: state.isHost,
    userId: state.userId,
    userName: state.userName,
    sessionId: state.sessionId
  }));
}

// Show error message
function showError(msg) {
  const errDiv = document.getElementById('passwordError');
  errDiv.textContent = msg;
  errDiv.style.display='block';
}

// Create or join session
async function createOrJoinSession() {
  // Check for existing active session
  const { data: sessions, error } = await supabase
    .from('sessions')
    .select('*')
    .eq('is_active', true);
  if (error) {
    alert('Error connecting to server');
    return;
  }

  if (sessions.length===0 && state.isHost) {
    // Create session
    const sessionId = generateId();
    const { data: newSession, error: err }= await supabase
      .from('sessions')
      .insert([{ session_id: sessionId, host_id: state.userId, host_name: state.userName, is_active:true, created_at: new Date().toISOString() }])
      .single();
    if (err) { alert('Failed to create session'); return; }
    state.sessionId = sessionId;
  } else {
    // Join existing
    const session = sessions[0]; // pick first
    // Add user info
    await supabase
      .from('sessions')
      .update({ guest_id: state.userId, guest_name: state.userName, guest_connected_at: new Date().toISOString() })
      .eq('session_id', session.session_id);
    state.sessionId = session.session_id;
  }
  // Setup real-time subscriptions
  setupRealtimeListeners();
}

// Generate unique ID
function generateId() {
  return 'id_' + Date.now() + '_' + Math.random().toString(36).substr(2,6);
}

/* --- Load Chat History & Image --- */
async function loadChatHistory() {
  const { data: msgs, error } = await supabase
    .from('messages')
    .select('*')
    .eq('session_id', state.sessionId)
    .order('created_at', { ascending:true });
  if (error) return;
  chatMessages.innerHTML = '';
  msgs.forEach(m => displayMessage(m));
}
async function loadCurrentImage() {
  const { data: session, error } = await supabase
    .from('sessions')
    .select('current_image')
    .eq('session_id', state.sessionId)
    .single();
  if (error || !session) return;
  if (session.current_image) {
    displayImage(session.current_image);
  }
}

/* --- Message Handling --- */
async function sendMessage() {
  const text = messageInput.value.trim();
  if (!text) return;
  // Save in DB
  const msg = {
    session_id: state.sessionId,
    sender_id: state.userId,
    sender_name: state.userName,
    message: text,
    created_at: new Date().toISOString()
  };
  await supabase.from('messages').insert([msg]);
  displayMessage(msg);
  messageInput.value='';
  // Play sound
  playNotificationSound();
}
function displayMessage(msg) {
  const div = document.createElement('div');
  div.className='message ' + (msg.sender_id===state.userId?'sent':'received');
  div.innerHTML = `
    <div class="message-sender">${msg.sender_name}</div>
    <div>${msg.message}</div>
    <div class="message-time">${new Date(msg.created_at).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}</div>
    ${msg.sender_id===state.userId ? `<button class="edit-btn" data-id="${msg.id}">Edit</button>` : ''}
    ${msg.sender_id===state.userId ? `<button class="reply-btn" data-id="${msg.id}">Reply</button>` : ''}
  `;
  chatMessages.appendChild(div);
  chatMessages.scrollTop=chatMessages.scrollHeight;
  // Attach edit/reply events
  if (msg.sender_id===state.userId) {
    div.querySelector('.edit-btn')?.addEventListener('click', ()=>editMessage(msg));
    div.querySelector('.reply-btn')?.addEventListener('click', ()=>replyToMessage(msg));
  }
}
async function editMessage(msg) {
  const newText = prompt('Edit your message:', msg.message);
  if (newText===null) return;
  await supabase.from('messages').update({ message: newText }).eq('id', msg.id);
  loadChatHistory(); // refresh
}
async function replyToMessage(msg) {
  messageInput.value = `Reply to ${msg.sender_name}: `;
  messageInput.focus();
}

/* --- Typing Status --- */
function handleTypingStatus() {
  if (!state.isTyping) {
    state.isTyping=true;
    sendTypingStatus(true);
  }
  clearTimeout(state.typingTimeout);
  state.typingTimeout=setTimeout(()=> {
    state.isTyping=false;
    sendTypingStatus(false);
  }, 2000);
}
function sendTypingStatus(isTyping) {
  // Use supabase real-time or simple custom
  // For simplicity, just broadcast to other user
  // Implement your real-time logic here
}

/* --- Clear Chat --- */
async function clearChat() {
  if (confirm('Clear chat?')) {
    // Delete from DB
    await supabase.from('messages').delete().eq('session_id', state.sessionId);
    // Clear local
    chatMessages.innerHTML='';
    // Notify users
    addSystemMessage('Chat cleared by user.');
  }
}

/* --- Review History --- */
async function reviewHistory() {
  // List latest sessions
  const { data:sessions } = await supabase
    .from('sessions')
    .select('*')
    .order('created_at', { ascending:false });
  sessionsContainer.innerHTML='';
  sessions.forEach(sess => {
    const card = document.createElement('div');
    card.className='session-card';
    if (sess.session_id===state.sessionId) card.classList.add('session-card-active');
    card.innerHTML= `
      <div><b>Session ID:</b> ${sess.session_id}</div>
      <div><b>Host IP:</b> ${sess.host_ip}</div>
      <div><b>Guest IP:</b> ${sess.guest_ip || 'N/A'}</div>
      <button data-id="${sess.session_id}" class="btn review-btn">Review</button>
      <button data-id="${sess.session_id}" class="btn download-btn">Download</button>
      <button data-id="${sess.session_id}" class="btn delete-btn">Delete</button>
    `;
    sessionsContainer.appendChild(card);
    card.querySelector('.review-btn').addEventListener('click', ()=>loadSessionHistory(sess.session_id));
    card.querySelector('.download-btn').addEventListener('click', ()=>downloadSession(sess.session_id));
    card.querySelector('.delete-btn').addEventListener('click', ()=>deleteSession(sess.session_id));
  });
}
async function loadSessionHistory(sessionId) {
  // Load messages
  const { data: msgs } = await supabase
    .from('messages')
    .select('*')
    .eq('session_id', sessionId)
    .order('created_at', { ascending:true });
  // Show in chat window, read-only
  chatMessages.innerHTML='';
  msgs.forEach(m => displayMessage(m));
  // Show "Historical chat" title
  chatMessages.insertAdjacentHTML('afterbegin', `<div class="system-title">Historical Chat - ${sessionId}</div>`);
}
async function downloadSession(sessionId) {
  const { data: msgs } = await supabase
    .from('messages')
    .select('*')
    .eq('session_id', sessionId);
  const content = msgs.map(m => `${m.sender_name} (${m.created_at}): ${m.message}`).join('\n');
  const blob=new Blob([content], {type:'text/plain'});
  const url= URL.createObjectURL(blob);
  const a= document.createElement('a');
  a.href=url; a.download=`Chat_${sessionId}.txt`;
  a.click();
  URL.revokeObjectURL(url);
}
async function deleteSession(sessionId) {
  if (!confirm('Delete this session?')) return;
  await supabase.from('sessions').delete().eq('session_id', sessionId);
  await supabase.from('messages').delete().eq('session_id', sessionId);
  refreshSessions();
}

/* --- Admin Panel --- */
async function refreshSessions() {
  const { data:sessions } = await supabase
    .from('sessions')
    .select('*')
    .order('created_at', { ascending:false });
  sessionsContainer.innerHTML='';
  sessions.forEach(sess => {
    const card = document.createElement('div');
    card.className='session-card';
    if (sess.session_id===state.sessionId) { card.classList.add('session-card-active'); state.activeSessionCardId=sess.session_id; }
    card.innerHTML= `
      <div><b>Session ID:</b> ${sess.session_id}</div>
      <div><b>Host IP:</b> ${sess.host_ip}</div>
      <div><b>Guest IP:</b> ${sess.guest_ip || 'N/A'}</div>
      <button data-id="${sess.session_id}" class="btn review-btn">Review</button>
      <button data-id="${sess.session_id}" class="btn download-btn">Download</button>
      <button data-id="${sess.session_id}" class="btn delete-btn">Delete</button>
    `;
    sessionsContainer.appendChild(card);
    card.querySelector('.review-btn').addEventListener('click', ()=>loadSessionHistory(sess.session_id));
    card.querySelector('.download-btn').addEventListener('click', ()=>downloadSession(sess.session_id));
    card.querySelector('.delete-btn').addEventListener('click', ()=>deleteSession(sess.session_id));
  });
}

// Highlight current active session card
function highlightActiveSessionCard() {
  document.querySelectorAll('.session-card').forEach(c => c.classList.remove('session-card-active'));
  if (state.activeSessionCardId) {
    const card = document.querySelector(`.session-card button[data-id="${state.activeSessionCardId}"]`)?.closest('.session-card');
    if (card) {
      card.classList.add('session-card-active');
    }
  }
}

/* --- Admin controls --- */
function showAdminPanel() {
  adminPanel.style.display='block';
  toggleAdminPanel();
}
function toggleAdminPanel() {
  if (adminContent.style.display==='none') {
    adminContent.style.display='block';
  } else {
    adminContent.style.display='none';
  }
}

/* --- Handle File Upload (Images) --- */
function handleFileUpload(e) {
  const file= e.target.files[0];
  if(!file || !file.type.startsWith('image/')) return;
  const reader= new FileReader();
  reader.onload= async ()=> {
    const dataUrl= reader.result;
    await saveImage(dataUrl);
  }
  reader.readAsDataURL(file);
}
async function saveImage(dataUrl) {
  // Save current_image in session
  await supabase.from('sessions').update({ current_image: dataUrl }).eq('session_id', state.sessionId);
  displayImage(dataUrl);
}

/* --- Display Image --- */
function displayImage(src) {
  // For inline message, send as message with type 'image'
  sendImageMessage(src);
}
function sendImageMessage(src) {
  // Send as message
  const msg= {
    session_id: state.sessionId,
    sender_id: state.userId,
    sender_name: state.userName,
    message: src,
    created_at: new Date().toISOString(),
    message_type: 'image'
  };
  supabase.from('messages').insert([msg]);
  displayMessage(msg);
}

/* --- Play notification sound --- */
function playNotificationSound() {
  const audio= new Audio('https://actions.google.com/sounds/v1/alarms/phone_alert.ogg'); // example
  audio.play();
}

/* --- Utility functions --- */
function generateId() { return 'id_'+Date.now()+'_'+Math.random().toString(36).substr(2,6); }

/* --- Real-time Listeners --- */
async function setupRealtimeListeners() {
  // Remove previous
  state.realTimeSubs.forEach(sub => supabase.removeChannel(sub));
  // Messages
  const msgChannel= supabase.channel('messages-'+state.sessionId);
  msgChannel.on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages', filter: 'session_id=eq.'+state.sessionId }, payload => {
    const msg= payload.new;
    if (msg.sender_id!==state.userId) {
      displayMessage(msg);
      playNotificationSound();
    }
  }).subscribe();
  state.realTimeSubs.push(msgChannel);
  // For user typing, implement similarly
}

/* --- UI functions --- */
function handleTypingStatus() {
  // Send typing status over real-time
  // Show indicator for other user
  if (!state.isTyping) {
    state.isTyping=true;
    broadcastTypingStatus(true);
  }
  clearTimeout(state.typingTimeout);
  state.typingTimeout=setTimeout(()=> {
    state.isTyping=false;
    broadcastTypingStatus(false);
  },2000);
}
function broadcastTypingStatus(isTyping) {
  // Implement real-time broadcast
}
</script>
</body>
</html>
